## 单一连续分配

内存在此方式下分为系统区和用户区，系统区仅提供给操作系统使用，通常在低地址部分；用户区是为用户提供的、除系统区之外的内存空间。这种方式无需进行内存保护。

这种方式的优点是简单、无外部碎片，可以釆用覆盖技术，不需要额外的技术支持。缺点是只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低。

## 固定分区分配

固定分区分配是最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干个固定大小的区域，每个分区只装入一道作业。当有空闲分区时，便可以再从外存的后备作业队列中,选择适当大小的作业装入该分区，如此循环。

固定分区分配在划分分区时，有两种不同的方法：

1. 分区大小相等：用于利用一台计算机去控制多个相同对象的场合，缺乏灵活性。
1. 分区大小不等：划分为含有多个较小的分区、适量的中等分区及少量的大分区。

## 动态分区分配

动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。这种分区方法不预先将内存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统中分区的大小和数目是可变的。
常见的动态分区的分配策略如下：

### 首次适应(First Fit)算法：

空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。该算法倾向于优先利用内存中低地址的空闲部分，保留高地址部分的大空闲区，为以后到达的大作业分配大空间创造条件。其缺点在于：低地址部分由于不断被划分，会留下许多难以利用的小空闲分区，并且，每次都从低地址开始检索，将增大可用空闲区间查找的开销。

### 最佳适应(Best Fit)算法：

空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区，即找到一个满足要求且最小的空闲分区分配给作业。孤立地看，最佳适应算法看似是最佳的，但是宏观看并非如此，存储器将留下许多难以利用的小空闲区。

### 最坏适应(Worst Fit)算法：

又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。
该算法优点是使剩下的空闲区不至于太小，产生碎片的几率最小，对中小作业有利，但对大作业不利。

### 循环首次适应(Next Fit)算法：

又称邻近适应算法，由首次适应算法演变而成。不同之处是分配内存时从上次查找结束的位置开始继续查找。该算法能使内存中的空闲分区分布得更均匀，从而减少了查找空闲分区的开销，但这样会缺乏大的空闲分区。

以上四种算法称为顺序搜索法，快速适应算法又称为分类搜索算法：

### 快速适应(Quick Fit)算法：

该算法将空闲分区按照大小进行分类，对每一类具有相同容量的所有空闲分区，单独设置一个空闲分区链表。分类通常常用空间大小进行划分，比如2KB,4KB,8KB等。仅需要根据进程的长度检索，找到能容纳它的最小空闲区链表，进行分配。
该算法优点是查找效率高，能够保留大的分区，满足用户对大空间的需求。缺点在于分区归还主存时算法复杂，系统开销较大，而且存在一定的空间浪费，是典型空间换时间的做法。

## 伙伴系统

Linux内核内存管理中采用伙伴系统解决外部碎片问题。伙伴系统的宗旨就是用最小的内存块来满足内核的对于内存的请求。

伙伴系统在回收空闲分区时，需要对空闲分区进行合并，其时间性能比前述分类搜索差，但比顺序搜索算法好，而其空间性能则远优于分类搜索算法，比顺序搜索算法略差。伙伴系统在多处理机系统中，仍不失为一种有效的内存分配和释放的方法，得到了大量的应用。

## 引用

1. [内存连续分配管理方式](https://www.jianshu.com/p/f9c2cd85e2f6)