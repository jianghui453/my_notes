# 死锁

死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

## 死锁的产生条件

1. **互斥条件**。只有对必须互斥使用的资源争抢（如打印机设备）才能导致死锁。
2. **不剥夺条件**。进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。如果进程可以抢夺其他进程持有自己需要的资源的话，也就不会产生死锁了，需要资源直接抢就行了。
3. **请求和保持条件**。进程已经保持了至少一个资源，但是又提出了新的资源需求，而该资源又被其他进程占有，此时请求进程被阻塞，但是又对自己持有的资源保持不放。也是很简单的道理，如果一个进程请求的资源被阻塞，就释放了自己持有的资源，其他进程就可以获取它释放的资源，也就不会发生相互等待而导致死锁了。
4. **循环等待条件**。存在一种进程资源的循环等待链，链中的每一个进程已经获得的资源同时被下一个进程所请求。

## 死锁处理策略

### 预防死锁

#### 破坏互斥条件

如果把只能互斥使用的资源改造成允许共享使用，则系统不会进入死锁状态。

#### 破坏不可剥夺性

方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时重新申请。
方案二：申请的资源被其他进程占用时，借助操作系统的协助，剥夺进程资源，至于剥夺哪个进程资源可以根据优先级考虑。

#### 破坏请求和保持条件

可以采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足之前，不让它运行。一旦运行，这些资源在运行期间一直归它所有，该进程就不会再请求别的任何资源。

#### 破坏循环等待条件

可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次申请完。

### 避免死锁

####  安全序列

如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全的。一个系统的安全序列可能有多个。

####  银行家算法

在进程提出资源请求时，先预先判断此次分配是否会导致系统进入不安全状态，如果进入不安全状态，就暂时不答应这次请求，让该进程先阻塞。

### 死锁的检测和解除

#### 死锁的解除

1. 资源剥夺法。挂起（暂时放在外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他进程，但是应防止被挂起长时间导致饥饿。
2. 撤销进程法。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这中方法实现简单，但是也是有代价的，如果有些已经运行了很长时间了，离成功只有一步之遥了，此时撤销导致功亏一篑，还需要从头再来....
3. 进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。

## 引用

1. [死锁及死锁的处理策略](https://www.jianshu.com/p/ffce6e264baa)
