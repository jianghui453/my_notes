# TCP 标志位的用法

## PSH与URG的区别

- PSH: 当前的数据还会被发送到接收端的缓冲区，并刷新缓冲区，将当前缓冲区中所有数据都交付给上一层——应用层。 PSH 位就是用来通告接收方立即将收到的报文连同TCP接收缓存里的数据递交应用进程处理，一般会出现在发送方封装最后一个应用字段的TCP报文中，针对TCP交互式应用,则只要封装有应用字段的TCP报文，均会将PSH位置1。当然，应用程序的开发者，可以根据需要，在某个应用功能模块或某个应用操作中,将所有封装应用字段的TCP报文PSH位置1，以提高交互双方的处理效率,这在理论上应该也是可行的。 
- URG: URG位有效的数据包也是在当前报文需要接收端立即处理，但是当前报文不需要经过接收端的缓冲区，直接越过缓冲区，交付往接收端的应用层。

## TCP处理程序会在自己认为的异常时刻发送RST包

1. **没有应用监听相应的端口**
    A向B发起连接，但B之上并没有应用监听相应的端口，这时B操作系统上的TCP处理程序会发RST包。
2. **请求超时**
    有89、27两台主机。主机89向主机27发送了一个SYN，表示希望连接8888端口，主机27回应了主机89一个SYN表示可以连接。但是主机89却很不友好，莫名其妙的发送了一个RST表示我不想连接你了。
    后来经过排查发现，在主机89上的程序在建立了socket之后，用setsockopt的SO_RCVTIMEO选项设置了recv的超时时间为100ms。而我们看上面的抓包结果表示，从主机89发出SYN到接收SYN的时间多达110ms。（从15:01:27.799961到15:01:27.961886， 小数点之后的单位是微秒）。因此主机89上的程序认为接收超时，所以发送了RST拒绝进一步发送数据。
3. **在一个已关闭的socket上收到数据**
    比如，AB正常建立连接了，正在通讯时，A向B发送了FIN包要求关连接，B发送ACK后，网断了，A通过若干原因放弃了这个连接（例如进程重启）。网通了后，B又开始发数据包，A收到后表示压力很大，不知道这野连接哪来的，就发了个RST包强制把连接关了，B收到后会出现connect reset by peer错误。
4. **字节流接收不完全**
    关于TCP，我想我们在教科书里都读到过一句话，'TCP是一种可靠的连接'。 而这可靠有这样一种含义，那就是操作系统接收到的来自TCP连接中的每一个字节，我都会让应用程序接收到。如果应用程序不接收怎么办？RST。
    打开一个socket然后连接一个服务器并发送5000个字节。刚才我们看服务器的代码，每次只接收4096个字节，那么就是说客户端发送的剩下的4个字节服务端的应用程序没有接收到，服务器端的socket就被关闭掉，这种情况下服务器就会向客户端发送了一个RST，断开连接

## 引用

1. [TCP标志位 RST作用、原理、攻击](https://blog.csdn.net/h2604396739/article/details/85255092)
